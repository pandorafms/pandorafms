#!/usr/bin/perl
##########################################################################
# Pandora FMS Plugin Server
##########################################################################
# Copyright (c) 2008 Sancho Lerena, slerena@gmail.com
#           (c) 2008 Artica Soluciones Tecnologicas S.L
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; version 2 (only).
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
##########################################################################

# Includes list
use strict;
use warnings;

use Date::Manip;        # Needed to manipulate DateTime formats of input, output and compare
use Time::Local;        # DateTime basic manipulation
use threads;
use threads::shared;

# Pandora Modules
use PandoraFMS::Config;
use PandoraFMS::Tools;
use PandoraFMS::DB;

# Queue management
my @pending_task : shared;
my %pending_task_hash : shared;
my %current_task_hash : shared;
my $queue_lock : shared;


# FLUSH in each IO (only for debug, very slooow)
# ENABLED in DEBUGMODE
# DISABLE FOR PRODUCTION
$| = 0;

my %pa_config;

$SIG{'TERM'} = 'pandora_shutdown';
$SIG{'INT'} = 'pandora_shutdown';

# Inicio del bucle principal de programa
pandora_init(\%pa_config, "Pandora FMS Plugin Server");

# Read config file for Global variables
pandora_loadconfig (\%pa_config, 4);

# Audit server starting
pandora_audit (\%pa_config, "Pandora FMS Plugin server starting", "SYSTEM", "System");

# Daemonize and put in background
if ( $pa_config{"daemon"} eq "1" ){
    if ($pa_config{"quiet"} eq "0"){
	    print " [*] Backgrounding Pandora FMS Plugin Server process.\n\n";
    }
	&pandora_daemonize ( \%pa_config);
}

# Launch now all plugin threads
# $ax is local thread id for this server
for (my $ax=0; $ax < $pa_config{'plugin_threads'}; $ax++){
	threads->new( \&pandora_plugin_consumer, \%pa_config, $ax);
}

# Launch now the producer thread
threads->new( \&pandora_plugin_producer, \%pa_config);

# Last thread is the main process (this process)
if ($pa_config{"quiet"} == 0){
    print " [*] All threads loaded and running \n\n";
}

# Start Pandora FMS loggin 
pandora_startlog (\%pa_config);

my $dbhost = $pa_config{'dbhost'};
my $dbname = $pa_config{'dbname'};
my $dbh = DBI->connect("DBI:mysql:$dbname:$dbhost:3306",
						$pa_config{'dbuser'},
						$pa_config{'dbpass'},
						{ RaiseError => 1, AutoCommit => 1 });

# Server keepalive thread running in main thread on a infinite loop
while (1) {
	pandora_serverkeepaliver (\%pa_config, 4, $dbh);
	threads->yield;
	sleep ($pa_config{"server_threshold"});
}

#------------------------------------------------------------------------------------
#------------------------------------------------------------------------------------
#------------------------------------------------------------------------------------
#---------------------  Main Perl Code below this line-----------------------
#------------------------------------------------------------------------------------
#------------------------------------------------------------------------------------
#------------------------------------------------------------------------------------

########################################################################################
# pandora_shutdown ()
# Close system
########################################################################################
sub pandora_shutdown {
    logger (\%pa_config,"Pandora FMS Server '".$pa_config{'servername'}.$pa_config{"servermode"}."' Shutdown by signal ",0);
    print " [*] Shutting down ".$pa_config{'servername'}.$pa_config{"servermode"} ."(received signal)...\n";
    pandora_event (\%pa_config, $pa_config{'servername'}.$pa_config{"servermode"}." going Down", 0,
                                   0, 4, 0, 0, "system", $dbh);
    exit;
}

##########################################################################
# SUB pandora_plugin_consumer_subsystem
# Subsystem to process Plugin modules
# This module runs each X seconds (server threshold) checking for Plugin modules status
##########################################################################
sub pandora_plugin_consumer ($$) {
	my $pa_config = $_[0];
	my $thread_id = $_[1];

    if ($pa_config->{"quiet"} == 0){
	    print " [*] Starting up Plugin Consumer Thread # $thread_id \n";
    }
	
	my $data_id_agent_module;
	# Create Database handler
	my $dbh = DBI->connect("DBI:mysql:$pa_config->{'dbname'}:$pa_config->{'dbhost'}:3306", $pa_config->{'dbuser'}, $pa_config->{'dbpass'}, { RaiseError => 1, AutoCommit => 1 });
	my $counter =0;
	
	LOOP: while (1) {
		if ($counter > 10) {
            threads->yield;
			sleep (1);
			$counter = 0;
		}
		
		# Take the first element on the shared queue
		# Insert this element on the current task hash
		{
			lock $queue_lock;
			if (scalar(@pending_task) == 0){
				$counter++;
				next LOOP;
			}

			$data_id_agent_module = shift(@pending_task);
			delete($pending_task_hash{$data_id_agent_module});
			$current_task_hash{$data_id_agent_module}=1;
		}
			
		# Executing network task with unmanaged error trapping
		eval {
			# Call network execution process
			# exec_network_module ( $pa_config, $data_id_agent_module, $dbh);
        	        exec_plugin_module ($pa_config, $data_id_agent_module, $dbh);
		};
		if ($@){
			logger ($pa_config, "[ERROR] Plugin Task for module $data_id_agent_module causes a system exception", 0);
			logger ($pa_config, "ERROR Code: $@", 1);
		}

		# Remove from queue. If catch an error, probably data is
		# not been processed, but has been freed from task queue
		{
			lock $queue_lock;
			delete($current_task_hash{$data_id_agent_module});
		}
		$counter = 0;
        threads->yield;
	}
}

sub pandora_plugin_producer ($) {
	my $pa_config = $_[0];
	print " [*] Starting up Plugin Producer Thread ...\n";

	my $dbh = DBI->connect("DBI:mysql:$pa_config->{'dbname'}:$pa_config->{'dbhost'}:3306", $pa_config->{'dbuser'}, $pa_config->{'dbpass'}, { RaiseError => 1, AutoCommit => 1 });
	my $server_id = $pa_config->{'server_id'};

	# Initialize variables for posterior usage
	my $query1;
	my @sql_data1;
	my $data_id_agente_modulo;
	my $data_flag;
	my $exec_sql1;
	
	while (1) {
		if ($pa_config->{"pandora_master"} != 1) {
			# Query for normal server, not MASTER server
			$query1 = "SELECT
				tagente_modulo.id_agente_modulo,
				tagente_modulo.flag
			FROM
				tagente, tagente_modulo, tagente_estado
			WHERE
				id_plugin_server = $server_id
			AND 
				tagente_modulo.id_agente = tagente.id_agente
			AND
				tagente.disabled = 0
            AND
                tagente_modulo.id_plugin != 0
			AND
				tagente_modulo.disabled = 0
			AND
				tagente_estado.id_agente_modulo = tagente_modulo.id_agente_modulo
			AND (
					(tagente_estado.last_execution_try + tagente_estado.current_interval) < UNIX_TIMESTAMP() 
				OR 
					tagente_modulo.flag = 1
			)				
			ORDER BY
					last_execution_try ASC  ";
		} else {
			# Query for MASTER SERVER !
			$query1 = "SELECT
					DISTINCT(tagente_modulo.id_agente_modulo), tagente_modulo.flag
				FROM
					tagente, tagente_modulo, tagente_estado, tserver
				WHERE
				( 	(tagente.id_plugin_server = $server_id AND tagente_modulo.id_agente = tagente.id_agente) OR
					(tagente.id_plugin_server != $server_id AND tagente_modulo.id_agente = tagente.id_agente AND tagente.id_plugin_server = tserver.id_server AND tserver.status = 0)
				) AND
					tagente.disabled = 0
                AND 
                    tagente_modulo.disabled = 0
				AND
					tagente_modulo.id_plugin != 0
				AND
					tagente_estado.id_agente_modulo = tagente_modulo.id_agente_modulo
				AND
					((tagente_estado.last_execution_try + tagente_estado.current_interval) < UNIX_TIMESTAMP() OR tagente_modulo.flag = 1 )
				ORDER BY last_execution_try ASC";
		}
		$exec_sql1 = $dbh->prepare($query1);
		$exec_sql1 ->execute;
		while (@sql_data1 = $exec_sql1->fetchrow_array()) {	
			$data_id_agente_modulo = $sql_data1[0];
			$data_flag = $sql_data1[1];

			# Skip modules already queued
			if ((!defined($pending_task_hash{$data_id_agente_modulo})) &&
				(!defined($current_task_hash{$data_id_agente_modulo}))) {
				if ($data_flag == 1){
					$dbh->do("UPDATE tagente_modulo SET flag = 0 WHERE id_agente_modulo = $data_id_agente_modulo")
				}
				# Locking scope, do not remove redundant { }
				{
					lock $queue_lock;
					push (@pending_task, $data_id_agente_modulo);
					$pending_task_hash {$data_id_agente_modulo}=1;
				}
			}
		}
		$exec_sql1->finish();
        threads->yield;
		sleep($pa_config->{"server_threshold"});
	} # Main loop
}


##########################################################################
# SUB exec_plugin_module (paconfig, id_agente_modulo, dbh )
# Execute plugin module task 
##########################################################################
sub exec_plugin_module {
    my $pa_config       = $_[0];
    my $id_am           = $_[1];
    my $dbh             = $_[2];

    # Set global variables for this sub
    my $timeout = $pa_config->{'plugin_timeout'};
	my $agent_module; # hash container for tagente_modulo record
    my $plugin; # hash container for tplugin

    # Get a full hash for agent_plugin record reference ($agent_module)
	my $query_sql = "SELECT * FROM tagente_modulo WHERE id_agente_modulo = $id_am";
	my $exec_sql = $dbh->prepare($query_sql);
	$exec_sql ->execute;
	$agent_module = $exec_sql->fetchrow_hashref;

    # Get a full hash for plugin record reference ($plugin)
    $query_sql = "SELECT * FROM tplugin WHERE id = ".$agent_module->{'id_plugin'};
    $exec_sql = $dbh->prepare($query_sql);
    $exec_sql->execute();
    $plugin = $exec_sql->fetchrow_hashref;

    # Calculate min timeout for this call
    if ($plugin->{'max_timeout'} < $timeout){
        $timeout = $plugin->{'max_timeout'};
    }

    # Initialize another global sub variables.
	my $agent_name = dame_agente_nombre ($pa_config, $agent_module->{'id_agente'}, $dbh);
	my $module_result = 1;  # Fail by default
	my $module_data = 0;    # 0 data for default
    my $module_interval = 0;

    # Build execution command to plugin
    my $exec_output = "";
    my $plugin_command = $plugin->{"execute"};
    if ($plugin->{'net_dst_opt'} ne ""){
        $plugin_command = $plugin_command . " ". $plugin->{'net_dst_opt'} ." ". $agent_module->{'ip_target'};
    } 
    if ($plugin->{'net_port_opt'} ne "") {
        $plugin_command = $plugin_command . " ". $plugin->{'net_port_opt'} ." ". $agent_module->{'tcp_port'};
    }
    if ($plugin->{'user_opt'} ne "") {
        $plugin_command = $plugin_command . " ". $plugin->{'user_opt'} ." ". $agent_module->{'plugin_user'};
    }
    if ($plugin->{'pass_opt'} ne "") {
        $plugin_command = $plugin_command . " ". $plugin->{'pass_opt'} ." ". $agent_module->{'plugin_pass'};
    }

    # Proccess field / optional / dynamic field
    if ($agent_module->{'plugin_parameter'} ne "") {
        $plugin_command = $plugin_command . " ". $agent_module->{'plugin_parameter'};
    }
    logger ($pa_config, "Executing AM # $id_am plugin command '$plugin_command'", 9);
    # Final command line execution is stored at "plugin_command"
    eval {
        alarm ($timeout);
        $module_data = `$plugin_command`;
        alarm(0); # Cancel the pending alarm if plugin call returns alive
        $module_result = 0; # If comes here, this is a successfull exec
    };

    # Timeout 
    if ($@ =~ /PANDORA PLUGIN SERVER TIMED OUT/) {
        logger ($pa_config, "[ERROR] Plugin Task for module ".$agent_module->{'id_agente_modulo'}." causes a system timeout in exec", 1);
        logger ($pa_config, "Executing plugin command '$plugin_command'", 9);

    # General error, not timed-out
    } elsif ($module_result == 1) { 
        logger ($pa_config, "[ERROR] Plugin Task for module ".$agent_module->{'id_agente_modulo'}." causes an unknown system error", 1);
        logger ($pa_config, "[ERROR] $@", 1);
    }

    sub timed_out {
        die "PANDORA PLUGIN SERVER TIMED OUT";
    }

	# Get current timestamp
	my $timestamp = &UnixDate("today","%Y-%m-%d %H:%M:%S");
	my $utimestamp = &UnixDate("today","%s");

    # If module execution get a valid value
	if ($module_result == 0) {
		my %part;
		$part{'name'}[0] = $agent_module->{'nombre'};
		$part{'description'}[0] = "";
		$part{'data'}[0] = $module_data;
        my $tipo_modulo = dame_nombretipomodulo_idagentemodulo ($pa_config, $agent_module->{'id_tipo_modulo'}, $dbh);

        # 1 - generic_data
        # 2 - generic_proc
        # 3 - generic_data_string
        # 4 - generic_data_inc
        # 19, 20 - image

		if (1 == $agent_module->{'id_tipo_modulo'}) {
			module_generic_data ($pa_config, \%part, $timestamp, $agent_name, $tipo_modulo, $dbh);
		}
		elsif (4 == $agent_module->{'id_tipo_modulo'}) {
			module_generic_data_inc ($pa_config, \%part, $timestamp, $agent_name, $tipo_modulo, $dbh);
		}
		elsif (3 == $agent_module->{'id_tipo_modulo'}) {
			module_generic_data_string ($pa_config, \%part, $timestamp, $agent_name, $tipo_modulo, $dbh);
		}
        # Generic_proc
		elsif (2 == $agent_module->{'id_tipo_modulo'}) {
			module_generic_proc ($pa_config, \%part, $timestamp, $agent_name, $tipo_modulo, $dbh);
		}
        elsif ( (19 == $agent_module->{'id_tipo_modulo'}) || (20 == $agent_module->{'id_tipo_modulo'}) ) {
            module_generic_image ($pa_config, \%part, $timestamp, $agent_name, $tipo_modulo, $dbh);
        }
		else { # Unknown module!, this IS a problem
			logger ($pa_config, "Plugin Server Problem with unknown module type '$tipo_modulo'", 0);
            $module_result = 1;
		}
		# Update agent last contact
		# Insert Pandora version as agent version
		pandora_lastagentcontact ($pa_config, $timestamp, $agent_name,  $pa_config->{'servername'}.$pa_config->{"servermode"}, $pa_config->{'version'}, -1, $dbh);
	} 

    # If something went wrong in module processing...
    if ($module_result != 0){ 

        # If module execution get a INVALID value
		if ($agent_module->{'intervalo'} == 0){
            $module_interval = dame_intervalo ($pa_config, $agent_module->{'id_agente'}, $dbh);
        }

		# Modules who cannot connect or something go bad, update last_execution_try field
		logger ($pa_config, "Cannot obtain exec plugin Module ".$agent_module->{'nombre'}." from agent $agent_name", 2);
		my $query_act = "UPDATE tagente_estado SET current_interval = $module_interval, last_execution_try = $utimestamp WHERE id_agente_modulo = ".$agent_module->{'id_agente_modulo'};
        $dbh->do($query_act);
	}

	$exec_sql->finish(); #close tagent_plugin hash reference
}
