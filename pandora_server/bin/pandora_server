#!/usr/bin/perl
##########################################################################
# Pandora Data Server
##########################################################################
# Copyright (c) 2004-2008 Sancho Lerena, slerena@gmail.com
# Copyright (c) 2008 Ramon Novoa, rnovoa@artica.es
# Copyright (c) 2005-2008 Artica Soluciones Tecnologicas S.L
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; version 2
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
##########################################################################

# Includes list
use strict;
use warnings;

use XML::Simple;                	# Useful XML functions
use Digest::MD5;                	# MD5 generation
use Time::Local;                	# DateTime basic manipulation
use DBI;                            # DB interface with MySQL
use Date::Manip;                	# Needed to manipulate DateTime formats of input, output and compare
use File::Copy;                     # Needed to manipulate files
use threads;
use threads::shared;

# Pandora Modules
use PandoraFMS::Config;
use PandoraFMS::Tools;
use PandoraFMS::DB;

# Queue management
my @pending_task : shared;
my %pending_task_hash : shared;
my %active_task_hash : shared;
my %incomplete_task_hash : shared;
my $queue_lock : shared;

# FLUSH in each IO, only for DEBUG, very slow !
$| = 0;

my %pa_config; 

$SIG{'TERM'} = 'pandora_shutdown';
$SIG{'INT'} = 'pandora_shutdown';

# Init main loop
pandora_init(\%pa_config,"Pandora FMS Data Server");

# Read config file for Global variables
pandora_loadconfig (\%pa_config,0);

# Audit server starting
pandora_audit (\%pa_config, "Pandora FMS Data Server Daemon starting", "SYSTEM", "System");

# Daemonize and put in background
if ( $pa_config{"daemon"} eq "1" ){
    if ($pa_config{"quiet"} eq "0"){
        print " [*] Backgrounding Pandora FMS Data Server process.\n\n";
    }
    &pandora_daemonize ( \%pa_config);
}

# Launch all data_consumer threads
for (my $ax=0; $ax < $pa_config{"dataserver_threads"}; $ax++){
	threads->new( \&pandora_data_consumer, \%pa_config, $ax);
}

# Launch producer thread
threads->new( \&pandora_data_producer, \%pa_config);

if ($pa_config{"quiet"} == 0){
    print " [*] All threads loaded and running \n\n";
}

# Start logging
pandora_startlog (\%pa_config);

my $dbhost = $pa_config{'dbhost'};
my $dbname = $pa_config{'dbname'};
my $dbh = DBI->connect("DBI:mysql:$dbname:$dbhost:3306",
						$pa_config{'dbuser'},
						$pa_config{'dbpass'},
						{ RaiseError => 1, AutoCommit => 1 });

# KeepAlive checks for Agents, only for master servers, in separate thread
while (1) {
	keep_alive_check (\%pa_config, $dbh);
	pandora_serverkeepaliver (\%pa_config, 0, $dbh);
	threads->yield;
	sleep ($pa_config{"server_threshold"});
}

########################################################################################
# pandora_shutdown ()
# Close system on a received signal
########################################################################################
sub pandora_shutdown {
	logger (\%pa_config,"Pandora FMS Data Server Shutdown by signal ",0);
	print " [*] Shutting down Pandora FMS Data Server (received signal)...\n";
	exit;
}

###############################################################################
# pandora_data_producer ()
# Queue data files available for processing
###############################################################################
sub pandora_data_producer {
	my $pa_config = $_[0];
	my $file_name;
	my $file;

	# Main loop
	while(1) {

		# Read all files in the incoming directory
		opendir(DIR, $pa_config->{'incomingdir'} )
		        || die "[FATAL] Cannot open Incoming data directory at " .
		        $pa_config->{'incomingdir'} . ": $!";

 		while (defined($file_name = readdir(DIR))){

			# For backward compatibility
			if ($file_name =~ /^.*\.checksum$/) {
				unlink("$pa_config->{'incomingdir'}/$file_name");
				next;
			} 

			# Data files have the extension .data
			if ($file_name !~ /^.*\.data$/) {
				next;
			}

			# Skip already queued/processed files
			if (defined($pending_task_hash{$file_name}) ||
			    defined($active_task_hash{$file_name})) {
				next;
			}

			# Queue data file
			{
				lock $queue_lock;
				push (@pending_task, $file_name);
				$pending_task_hash {$file_name} = 1;
				if (! defined($incomplete_task_hash{$file_name})) {
					$incomplete_task_hash{$file_name} = 0;
				}
			}

			threads->yield;
		}

        closedir(DIR);
		threads->yield;
        sleep $pa_config->{"server_threshold"};
	}
}

###############################################################################
# pandora_data_consumer ()
# Process data files
###############################################################################
sub pandora_data_consumer ($$) {
	my $pa_config = $_[0];
	my $thread_id = $_[1];

	my $file_name;
	my $counter =0;

    if ($pa_config->{"quiet"} == 0){
	    print " [*] Starting up Data Consumer Thread # $thread_id \n";
    }

	# Create database handler
	my $dbh = DBI->connect("DBI:mysql:" . $pa_config->{'dbname'} . ":" .
	                       $pa_config->{'dbhost'} . ":3306",
	                       $pa_config->{'dbuser'},$pa_config->{'dbpass'},
	                       { RaiseError => 1, AutoCommit => 1 });

	LOOP: while (1) {

		if ($counter > 10) {
			$counter = 0;
            threads->yield;		
			sleep (1);
		}

		# Check for pending data files
		{
			lock $queue_lock;
			if (scalar(@pending_task) == 0) {
				$counter++;
				next LOOP;
			}

			$file_name = shift(@pending_task);
			delete($pending_task_hash{$file_name});
			$active_task_hash{$file_name} = 1;
		}

		my $file = "$pa_config->{'incomingdir'}/$file_name";
		
		# Check file really exists to avoid race conditions
		if (! -e "$file") {
			$counter++;
			next LOOP;
		}
		
		my $data;

		# Parse the XML file
		eval {
        	logger ($pa_config, "Ready to parse $file_name",4);
            $data = XMLin($file, forcearray=>'module');
        };

		# Invalid MXL
        if ($@) {

			# Retry
			if ($incomplete_task_hash{$file_name} < 10) {
				{
					lock $queue_lock;
					delete($active_task_hash{$file_name});
					$incomplete_task_hash{$file_name} += 1;
				}
			}
			# Discard
			else {
				{
					lock $queue_lock;
					delete($active_task_hash{$file_name});
					delete($incomplete_task_hash{$file_name});
					rename($file, $file . "_BADXML");
				}
			}

			$counter = 0;
			next LOOP;
        }

		procesa_datos ($pa_config, $data, $dbh);

		{
			lock $queue_lock;
			delete($active_task_hash{$file_name});
			delete($incomplete_task_hash{$file_name});
			unlink($file);
		}

		$counter = 0;
	}
}

##########################################################################
## SUB keep_alive_check  ()
## Calculate a global keep alive check for agents without data and an alert defined 
##########################################################################

sub keep_alive_check {
	my $pa_config = $_[0];
	my $dbh = $_[1];
	my $timestamp = &UnixDate ("today", "%Y-%m-%d %H:%M:%S");
        my $utimestamp = &UnixDate ("today", "%s");
        my $query_idag = "SELECT tagente_modulo.id_agente_modulo, tagente_estado.utimestamp, tagente_estado.id_agente, tagente.intervalo, tagente.nombre, tagente_modulo.nombre FROM tagente_modulo, talerta_agente_modulo, tagente_estado, tagente WHERE tagente_modulo.id_agente_modulo = talerta_agente_modulo.id_agente_modulo AND talerta_agente_modulo.disable = 0 AND tagente_modulo.id_tipo_modulo = 100 AND tagente_estado.id_agente_modulo = tagente_modulo.id_agente_modulo AND tagente.id_agente = tagente_estado.id_agente AND tagente_estado.datos != 0";
        my $s_idag = $dbh->prepare($query_idag);
        $s_idag ->execute;

        my $id_agent_module;
        my $module_utimestamp;
        my $id_agent;
        my $interval;
        my $agent_name;
        my $module_name;

	# data needed in loop (we'll reuse it)
        my @data;
	if ($s_idag->rows != 0) {
		while (@data = $s_idag->fetchrow_array()) {
			threads->yield;
			$id_agent_module = $data[0];
                        $module_utimestamp = $data[1];
                        $id_agent = $data[2];
                        $interval = $data[3];
                        $agent_name = $data[4];
                        $module_name = $data[5];
                        # Agent down - Keepalive utimestamp too low (2x)
                        if (($module_utimestamp + ($interval * 2)) < $utimestamp){
                                pandora_writestate ($pa_config, $agent_name, "keep_alive", $module_name, 0, 1, $dbh, 1);
                        }
		}
	} 
	$s_idag->finish();
}

##########################################################################
## SUB procesa_datos (param_1)
## Process data packet (XML file)
##########################################################################
## param_1 : XML datafile name

sub procesa_datos {
        my $pa_config = $_[0];
        my $datos = $_[1]; 
        my $dbh = $_[2];
        
        my $tipo_modulo;
        my $agent_name; 
        my $timestamp;
        my $interval; 
        my $os_version;
        my $agent_version;
        my $id_agente;
        my $module_name;
    
	$agent_name = $datos->{'agent_name'};
	$timestamp = $datos->{'timestamp'};
	$agent_version = $datos->{'version'};
	$interval = $datos->{'interval'};
	$os_version = $datos->{'os_version'};
  
  	# Set default interval if not defined in agent (This is very very odd whatever!).
   	if (!defined($interval)){
		$interval = 300;
	}

	# Check for parameteres, not all version agents gives the same parameters !
	if (length($interval) == 0){
       $interval = -1; # No update for interval !
    }
   
   	if ((!defined ($os_version)) || (length($os_version) == 0)){
		$os_version = "N/A";
	}
  
	if (defined $agent_name){
		$id_agente = dame_agente_id($pa_config,$agent_name,$dbh);
		if ($id_agente > 0) {
			pandora_lastagentcontact ($pa_config, $timestamp, $agent_name, $os_version, $agent_version, $interval, $dbh);
			foreach my $part(@{$datos->{module}}) {
				$tipo_modulo = $part->{type}->[0];
				$module_name = $part->{name}->[0];
                if (defined($module_name)){ # Skip modules without names 
				    logger($pa_config, "Processing module Name ( $module_name ) type ( $tipo_modulo ) for agent ( $agent_name )", 5);
				    if ($tipo_modulo eq 'generic_data') {
					    module_generic_data ($pa_config, $part, $timestamp, $agent_name, "generic_data", $dbh);
				    }
				    elsif ($tipo_modulo eq 'generic_data_inc') {
					    module_generic_data_inc ($pa_config, $part, $timestamp, $agent_name,"generic_data_inc", $dbh);
				    }
				    elsif ($tipo_modulo eq 'generic_data_string') {
					    module_generic_data_string ($pa_config, $part, $timestamp, $agent_name,"generic_data_string", $dbh);
				    }
				    elsif ($tipo_modulo eq 'generic_proc') {
					    module_generic_proc ($pa_config, $part, $timestamp, $agent_name, "generic_proc", $dbh);
				    }
				    else {
					    logger($pa_config, "ERROR: Received data from an unknown module ($tipo_modulo)", 2);
				    }
                }            
			}
		} else {
			logger($pa_config, "ERROR: There is no agent defined with name $agent_name ($id_agente)", 2);
		}
	} else {
		logger($pa_config, "ERROR: Received data from an unknown agent", 1);
	}
}
